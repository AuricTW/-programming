# C語言指標
*此筆記大多參考、引用自 Blogger：小狐狸事務所(超強）*

*以下的測試程式參考了下列幾本書的範例加以改編 :
C 語言初學指引第四版 (博碩, 陳錦輝)   
C 語言程式設計剖析 (全華, 簡聰海)    
C 語言從零開始 (博碩, 資訊教育研究室)    
C 語言入門 (易習, 丁國棟)    
C 語言程式設計實例入門第四版 (博碩, 高橋麻奈)    
C 語言程式設計與應用 (全華, 陳會安)*  

原版使用了使用工具包括 Windows 上的 Dev C++, 樹莓派的 gcc, 以及線上 C 語言編譯器 TutorialsPoint  
在此僅使用Dev C++進行測試
## 零. 基本介紹
C 語言雖然是高階語言, 但指標功能卻讓 C 語言也擁有低階的記憶體操作能力. 許多高階語言也有支援指標, 例如 C++, FORTRAN, PASCAL, BASIC, Perl, C# 等等, 其中 C++ 除了完整支援 C 的指標功能外, 也新增了 Smart Pointers 以提供較原始指標更安全的功能. 部分支援指標的高階語言因為安全性等原因而對指標做了限制, 例如 PASCAL 與 C#, 而 Java 則完全不支援指標

指標的主要用途如下 :   
**1. 函式之間若要傳遞字串或陣列使用指標做傳址呼叫可避免資料的複製與搬移**    
**2. 需要從函式中傳回一個以上的值時必須使用指標, 因為 return 只能傳回一個一般變數值.**    
**3. 較複雜之資料結構需要利用指標以鏈結串列方式實作.**     
**4. 使用指標處理字串較方便.**    
  
事實上, 許多 C 語言內建函式內部都是使用指標實作的.事實上, 許多 C 語言內建函式內部都是使用指標實作的.

## 一. 指標變數的宣告與賦值
### 1. 指標是甚麼?
**指標是 C 語言中一種特別的資料型態, 專門用來儲存某個資料的記憶體位址, 其內容用來指向該資料.** 編譯器使用 CPU 的間接定址法來存取指標變數所指之記憶體


指標變數與一般變數不同, **其儲存的內容是記憶體位址, 因此占用的記憶體大小是固定的**, 即等於 CPU 的位址寬度, 例如 32 位元系統之位址匯流排寬度是 32 位元 (4 個 bytes), 可定址 2^32=4G Bytes 的 DRAM, 其指標變數長度為 4 個 Bytes; 而 64 位元系統位址匯流排 64 位元 (8 個 bytes), 定址能力為 2^64=16GB 之 DRAM,  其指標變數長度為 8 個 Bytes.

### 2. 指標變數的宣告 

**指標變數宣告方式是在變數名稱前面加 * 號 (ANSI C)** 或是在資料型態後面加 * (C++ 新增方式), 例如 :
```c
int *ptr;     //ANSI C 的宣告方式
int* ptr;     //C++ 新增的宣告方式
```
這都是宣告指向一個整數資料的指標變數 ptr. 指標變數宣告之後, 編譯器會在記憶體中指配記憶位址來儲存所指之位址. 指標變數在賦值之前其內容為記憶體之前的殘留值或隨機初始值, 此未初始化的指標變數是懸空的狀態 (dangling), 不可拿來使用, 因為它可能指向不允許存取的系統保留區或其他程序正在使用的記憶體位址, 可能導致運算結果錯誤或系統當機.

指標變數除了指向一般變數與陣列外, 也可以指向函數, 稱為函數指標, 其宣告方式例如 :
```c
int *ftpr (int x,int y);
```
這是宣告一個指向函數的指標 fptr, 詳如後述.
### 3. 指標變數的賦值 (初始化)
指標變數在使用前必須 **初始化 (賦值)** 以指向某一個記憶體位址; 亦即透過指定運算將一個記憶體位址存入指標內. 指標賦值有兩種方式 :
 **使用取址運算子 & (reference operator)**
 將本身就是位址的 **陣列名稱**或 **函數名稱**指派給指標 
取址運算子 & 可以取得任意變數 (包含指標變數) 之記憶體位址, 例如 :
```c
int a=100;                      //宣告一般變數 a 並賦值 100
int *ptr;                          //宣告指向整數資料的指標
ptr=&a;                 //取得 a 的記憶體位址並賦值給指標 ptr
```
也可以在宣告指標的同時予以賦值, 上面的程式可改為 :
```c
int a=100;
int *ptr=&a;          //取得 a 的記憶體位址並賦值給指標 ptr
```
### 4. 陣列指標
指標也可以指向陣列元素, 這種指標稱為陣列指標. 陣列的每一個元素相當於一般的變數, 因此可以用取址運算子 & 取得任一元素之記憶體位址, 然後指派給指標, 例如 :
```c
int a[]={0,1,2,3,4,5};
int *ptr=&a[0];              //宣告整數指標 ptr 指向整數陣列 a 的開頭位址
ptr=&a[3];                      //指標改為指向陣列 a 的第四個元素
```
將指標指向陣列開頭除了用 &a[0] 取得第一個元素的開頭位址外賦值外, 也可以直接用陣列名稱賦值, 因為陣列名稱本身就是指向其第一個元素的開始位址, 例如 :
```c
int *ptr=a;           //宣告整數指標 ptr 指向整數陣列 a 的開頭位址 (等於 &a[0])
```
從下面的範例可知, &a[0] 與 a 的內容是一樣的, 都是陣列 a 的開始位址 :
```c
#include <stdio.h>

int main() {
    int a[]={0,1,2,3,4,5};
    printf("a=%p\n",a);
    printf("&a[0]=%p\n",&a[0]);
    int *ptr=a;
    printf("ptr=%p\n",ptr);
    return 0;
    }
```
結果如下 :
```
a=0x7ffff331aa90       (陣列開始位址)
&a[0]=0x7ffff331aa90   (陣列開始位址)
ptr=0x7ffff331aa90     (指向陣列開始位址)
```
陣列其實是一種特殊的指標, 在編譯器的符號表中, a 儲存了第一個元素的開頭位址 `&a[0]`, 其內容是不可更改的 (否則會找不到陣列的開頭), 因此**陣列又稱為常數指標**. 一般的指標是變數, 其所儲存的內容 (記憶體位址) 是可以改變的, 可以做遞增遞減等算術運算, 例如 `++ptr` 或 `ptr--` 等等, 但是陣列 a 是常數指標, 不允許做 `a++` 或 `--a` 等運算.  
下列程式碼將編譯失敗, 因為陣列的起始位址是不能更改的 :
```c
int x=5;
int a[]={0,1,2,3,4,5};
int a=&x;      //不可更改陣列位址
```
在 Dev C++ 會出現如下錯誤訊息, 表示 a 已經被宣告為陣列, 不能更改 a 的位址 :
```
[Error] conflicting declaration 'int a'
[Note] previous declaration as 'int a [6]'
```
陣列指標除了可使用 `*(ptr+i)` 來存取陣列元素外, 也可以把指標當成陣列名稱, 使用索引 `ptr[i]` 來存取陣列元素, 例如 :
```c
#include <stdio.h>

int main() {
    int a[]={0,1,2,3,4,5};
    int *ptr=a;
    printf("a[2]=*(ptr+2)=%d\n",*(ptr+2));    //使用取值運算子
    printf("a[2]=ptr[2]=%d\n",ptr[2]);             //陣列指標也可以使用索引存取陣列元素
    return 0;
    }
```
執行結果如下 :
```
a[2]=*(ptr+2)=2
a[2]=ptr[2]=2
```
指標既然可以指向陣列, 當然也可以在函數中當虛引數 (參數) 接收呼叫者傳遞之陣列. 在函數之間傳遞陣列是以傳址呼叫方式將陣列名稱 (即起始位址) 傳入函數, 例如下列求陣列元素和的程式, 被呼叫的函式必須宣告一個同型態陣列來接收引數 :
```c
int sum(int a[], int len) {    //宣告一個整數陣列接收引數
    int s=0;
    for (int i=0; i<len; i++) {
        s=s + a[i];
        }
    return s;
    }

int main() {
    int len=6;
    int a[]={0,1,2,3,4,5};
    int s=sum(a,len);          //將陣列起始位址傳給函數 sum()
    printf("sum=%d",s);
    }
```
但是也可以改用指標來接收傳入之引數 :
```c
int sum(int *ptr, int len) {   //宣告一個整數指標接收引數
    int s=0;
    for (int i=0; i<len; i++) {
        s=s + *(ptr + i);     //或者 ptr[i] 亦可
        }
    return s;
    }

int main() {
    int len=6;
    int a[]={0,1,2,3,4,5};
    int s=sum(a,len);         //將陣列起始位址傳給函數 sum()
    printf("sum=%d",s);
    }
```

### 5. 字串指標
由於 C 語言沒有字串資料類型, 因此字串是利用陣列來儲存, 但與字元陣列不同之處是結尾必須加上一個 ASCII 的 `NULL` 字元 '\0', 例如 :
```c
char cha[5]={'H','E','L','L','O'};       //一般的字元陣列
char str[6]={'H','E','L','L','O','\0'};   //字串
```
也可以用雙引號給字元陣列賦值, 這時編譯器會自動在結尾處加上 NULL 字元 :
```c
char str[]="HELLO";   //用雙引號賦值
```
在 printf() 中輸出字串必須使用 `%s` 格式, 對應的變數就是陣列名稱; 如果是輸出其中的某個字元則要用 `%c` 格式, 例如 :
```c
int main() {
    char str[]="HELLO";
    printf("str=%s\n",str);             //輸出整個字串
    printf("str[1]=%c\n",str[1]);    //輸出單一字元
    return 0;
    }
```
既然字串是一種字元陣列, 指標可以指向陣列, 指向字串的指標稱為字串指標, 此指標必須宣告為 `char` 類型, 例如
```c
char *ptr="HELLO";       //指向字串的指標
printf("*ptr=%s\n",ptr);   //輸出字串
```
也可以在迴圈中用 putchar() 輸出字串, 例如 :
```c
int main() {
    char *ptr="HELLO";
    for (; *ptr != '\0'; *ptr++) {    //或 while(*ptr != '\0')  亦可
        putchar(*ptr);
        }
    return 0;
    }
```
如果是用陣列的話必須用一個索引計數器, 上面的指標就不用 :
```c
int main() {
    char str[]="HELLO";
    int i=0;    //索引計數器
    while(str[i] != '\0') {
        putchar(str[i]);
        ++i;
        }
    return 0;
    }
```
雖然陣列與指標都能用來處理字串, 但它們最大的不同是, 陣列字串一經賦值即不可再指派新值, 因為陣列是常數指標, 其內容是不可變的, 例如下面的程式碼無法通過編譯 :
```c
    char str[]="HELLO";   //陣列名稱 str 是常數不是變數 (常數指標)
    str="WORLD";     //無法通過編譯
```
因為陣列 `str` 已經指向 "HELLO" 的開頭, 不能再指向 "WORLD".

而指標是變數, 可隨時指向任何字串, 上面的字串改用指標就可以通過編譯了, 例如 :
```c
    char *ptr="HELLO";   //原指向 "HELLO"
    ptr="WORLD";           //改為指向 "WORLD"
```
如果要交換兩個字串必須使用字串指標, 不能用字元陣列, 參考簡聰海寫的 "C 語言程式設計剖析" 8-6 節 :
```c
int main() {
    char *a="Hello";      //不可以用 a[] 取代 *a
    char *b="World";     //不可以用 b[] 取代 *b
    char *tmp;
    printf("交換前:a=%s b=%s\n",a,b);
    tmp=a;
    a=b;
    b=tmp;
    printf("交換後:a=%s b=%s\n",a,b);
    return 0;
    }
```
執行結果 :
```
交換前:a=Hello b=World
交換後:a=World b=Hello
```
雖然指標與陣列都能用來存取字串, 但上面 `main` 的前兩行若改用陣列 :
```c
    char a[]="Hello";     
    char b[]="World";   
```
這樣就無法通過編譯了, 因為它在後面的 a=b 與 b=bmp 就會發生編譯錯誤 :
```
main.c:9:6: error: assignment to expression with array type
     a=b;
      ^
main.c:10:6: error: assignment to expression with array type
     b=tmp;
      ^
```
因為陣列 a 與 b 一經宣告後, 其內容 (指向陣列開頭之位址) 就固定不能再改變了.

指標除了可以指向陣列外, 也可以指向函數, 與陣列名稱代表陣列的開始位址一樣, 函數名稱代表函數的開始位址, 因此可以將函數名稱指派給指標變數, 使其指向該函數, 留待後面再行測試.


### 6. 不可指派常數值給指標
直接對指標變數本身或其所指位址指派一個整數常數或字面值 (Literal) 是非常危險與錯誤的用法
 例如 :
```c
int *ptr=1000;   
```
或
```c
int *ptr; 
ptr=1000;   
```
此指令在宣告指標變數 `ptr` 的同時也對其賦值 1000, 由於 `ptr` 在宣告後, 這位址 1000 可能指向系統或其他程序所使用的記憶體位址, 輕則破壞其他程式之運算結果, 重則導致保護較不周全之作業系統 (如 DOS) 當機.

#### 測試 1 : 錯誤的指標賦值方式  
```c
#include <stdio.h>

int main() {
    int a=2;
    int *ptr=1000;   
    return 0;
  }
```
此程式在 Dev C++ 編譯會得到下列錯誤訊息 :
```
[Error] invalid conversion from 'int' to 'int*' [-fpermissive]
```
#### 測試 2 : 顯示未初始化之指標內容 

#### 測試 3 : 利用指標更改所指位址內容 

### 7. 用指標當函數參數進行傳址呼叫 
C 語言函數的 return 只能傳回一個值, 如果要傳回多個值必須利用指標或陣列的傳址呼叫才能達成, 在 "C 語言從零開始" 這本書的 11-7 節以及 "最新 C 語言程式設計實例入門" 的 9-3 節提到的兩個變數數值交換函數 swap() 唯一極佳範例, 改寫如下 :
#### 測試 4 : 利用指標傳址呼叫交換兩個變數之數值
```c
#include <stdio.h>

void swap(int *x,int *y) {  //函數的參數為指標 (不需傳回值)
   int tmp=*x;
   *x=*y;
   *y=tmp;
   }

int main() {
    int a=5,b=15;
    printf("交換前 : a=%d b=%d\n",a,b);
    swap(&a,&b);    //以傳址呼叫將 a, b 之位址傳給函數
    printf("交換後 : a=%d b=%d\n",a,b);
    return 0;
    }
```
由於要傳回的值有兩個 (即交換後的 a, b), 因此將 a, b 的位址傳給 swap() 去運算, 因為指標指向了變數的位址, 直接在變數上進行交換動作, 因此也用不到 return 將值傳回來, 故傳回值宣告為 void. 執行結果如下 :
```
交換前 : a=5 b=15
交換後 : a=15 b=5
```
如果將 swap() 改成如下用傳值呼叫的話, 由於傳進去的是資料的副本, 如果不將資料傳回來的話就是做白工 :
```c
int swap(int x,int y) {  //傳值呼叫 : 無效的數值交換
   int tmp=x;
   x=y;
   y=tmp;
   }
```

## 二. 指標的長度
指標變數與一般變數不同, 其儲存的內容是記憶體位址 (整數), 因此不論指標指向哪一種型態的資料, 其所占記憶體大小是固定的, , 即等於 CPU 的位址寬度, 例如 32 位元系統之位址匯流排寬度是 32 位元 (4 個 bytes), 可定址 2^32=4G Bytes 的 DRAM, 其指標變數長度為 4 個 Bytes; 而 64 位元系統位址匯流排為 64 位元 (8 個 bytes), 定址能力為 2^64=16GB 之 DRAM,  其指標變數長度為 8 個 Bytes. 例如 :

#### 測試 5 : 指向各種型態的指標都占用相同大小的記憶體   

```c
#include <stdio.h>

int main() {
    char c;
    int i;
    float f;
    double d;
    char *cptr=&c;
    int *iptr=&i;
    float *fptr=&f;
    double *dptr=&d;
    printf("變數名稱     記憶體位址          占用記憶體 (bytes)\n");
    printf("========    ================   ==================\n");
    printf("   c  \t    %p \t  %d\n", &c, sizeof(c));
    printf("   i  \t    %p \t  %d\n", &i, sizeof(i));
    printf("   f  \t    %p \t  %d\n", &f, sizeof(f));
    printf("   d  \t    %p \t  %d\n", &d, sizeof(d));
    printf(" cptr  \t    %p  \t  %d\n", &cptr, sizeof(cptr));
    printf(" iptr  \t    %p  \t  %d\n", &iptr, sizeof(iptr));
    printf(" fptr  \t    %p  \t  %d\n", &fptr, sizeof(fptr));
    printf(" dptr  \t    %p  \t  %d\n", &dptr, sizeof(dptr));
    return 0;
   }
```
在 Win10 64 位元系統的 Dev C++ 執行結果如下 :
```
變數名稱     記憶體位址          占用記憶體 (bytes)
========    ================   ==================
   c        000000000062FE1F      1
   i        000000000062FE18      4
   f        000000000062FE14      4
   d        000000000062FE08      8
 cptr       000000000062FE00      8
 iptr       000000000062FDF8      8
 fptr       000000000062FDF0      8
 dptr       000000000062FDE8      8
```
## 三. 指標的運算 
### 1. 指標加減運算　
#### 測試 6 : 指標加減指向陣列元素  
#### 測試 7  :  指標加減在各類型資料的位址的移位距離  
### 2. 指標差值運算  
#### 測試 8 : 兩個指標間之距離  
### 3. 遞增 (++) 與遞減 --) 運算  
#### 測試 9 : 指標 *, ++,  () 的混合運算  


### 4. 指標比較運算 

## 四. 指標的指標
![](https://i.imgur.com/rdWOYnn.jpg)
指標變數用來儲存資料的記憶體位址, 指標除了用來指向一般變數, 也可以用來指向另一個指標變數, 稱為雙重指標. C 語言允許多重指標, 但因較複雜而用得不多. 宣告多重指標的方式是使用連續的 "*", 例如 :
```c
char ***ppp;  //宣告三重指標 ppp
```
從下面範例可以觀察三重指標儲存的位址之關係 : 
####　測試 10 : 三重指標

```ｃ
#include <stdio.h>

int main() {
    int a=100;
    int *ptr1=&a;             //指向整數的指標
    int **ptr2=&ptr1;      //指向整數指標的指標
    int ***ptr3=&ptr2;    //指向整數指標的指標的指標
    printf("&a=%p a=%d\n",&a,*ptr1);
    printf("&ptr1=%p ptr1=%p *ptr1=%d\n",&ptr1,ptr1,*ptr1);
    printf("&ptr2=%p ptr2=%p *ptr2=%p\n",&ptr2,ptr2,*ptr2);
    printf("&ptr3=%p ptr3=%p *ptr3=%p\n",&ptr3,ptr3,*ptr3);
    return 0;
    }
```
TutorialsPoint 執行結果如下：
![]([https://ibb.co/d6rDLkz](https://i.imgur.com/7x7LOyv.png))

在上面的範例中, 指標 ptr1 指向一個整數變數 a, 儲存的是 a 的位址 7fff5e45bb2c, 而指標 ptr2 又指向 ptr1; 儲存的是ptr1 的位址 7fff5e45bb20; 指標 ptr3 又指向 ptr2, 儲存的是 ptr2 的位址 7fff5e45bb18, 形成三重指標. 由於最終是指向一個整數, 因此這三個指標都必須宣告為 int.


## 五. 函數指標

## 六. 泛型指標 void

